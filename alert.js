// Этот код используется в строгом режиме
"use strict";

alert("Привет");

alert("Мир");

let user1 = "John";
let age23 = 25;
let message12 = "Hello";
message12 = "Hellow";
let myVelyLong = "Vityaz";
let user123 = "123";
let _ = "3";
let $ = "4";
alert("_+$"); //7

alert("age"); 




let admin, name23, user23;
user23 = "John";
admin = user23;
alert( admin );  


/*const myBirthday = "16.01.1986"; - правильное
myBirthday = "19.02.2090"; - неправильное*/

const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00

let ourPlanetName = "Земля";
let currentUserName = "Джон";
let mainUserName = "Мария";

/*const BIRTHDAY = '18.04.1982'; 

const AGE = first(BIRTHDAY); */

/*Типы данных*/
/*Динамическая типизация - типы данных есть, но переменные не привязаны ни к одному из них*/
let message = "12345";
message = "User";

/*Число*/
let n = "12345";
n = "12.345";
alert (1/0); // (1/0 = Infinity) - бесконечность
alert ("не число"/ 2+5); //Nan - мат ошибка
/*const bigInt = 1234567890123456789012345678901234567890n;  bigInt - это тип, который дает прописывать огроменные числа с n в конце*/


/*Строка*/
/*let str0 = "Привет";
let str1 = `${str}`; //Обратные кавычки позволяют встраивать переменные `${str}`;*/
let name123 = "Иван";
alert ( `Привет, ${name123}!` );
alert (`результат: ${1+2}`);
alert (`вывод: ${250+250}`);

/*Булевый логический тип*/
//Булевый тип (boolean) может принимать только два значения: true (истина) и false (ложь).
let isGreater = 5 > 1;
alert(isGreater); // true - результатом сравнения будет да

/*Спец значение null - представляет собой «ничего», «пусто» или «значение неизвестно»*/
let age1 = null; // Значение неизвестно

/*Специальное значение undefined - значение не было присвоено; undefined – для проверок, была ли переменная назначена.*/
let ag1e = 123;
ag1e = undefined;
alert (ag1e);

/*Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной. Используется для вывода имени той или иной переменной
Имеет две формы: typeof x или typeof(x).*/
typeof 0 // "number" , т.е. ноль - это число - значит тип данных number
typeof 10n // "bigint"
typeof true // "boolean"

let name = "Ilya";

alert(`hello ${1}`);
alert(`hello ${"name"}`);
alert (`hello ${name}`);

/*Взаимодействие: alert, prompt, confirm*/
/*Функция prompt принимает два аргумента:
title - Текст для отображения в окне.
default - Необязательный второй параметр, 
который устанавливает начальное значение в поле для текста в окне.
result = prompt(title, [default]);*/
let age = prompt(`Сколько тебе лет?`, 100);
alert (`Тебе ${age}лет!`); // Тебе 100 лет! 

/*Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.
Результат – true, если нажата кнопка OK. В других случаях – false.
result = confirm(question);*/
let isBoss = confirm("Ты здесь главный?");
alert(isBoss); //true - если нажата ОК


let name1231 = prompt("Ваше имя?", "");
alert(name1231);

/*Преобразование типов*/

/*Строковое преобразование - value
alert(value) преобразует значение к строке
String(value) преобразует значение к строке
Преобразование происходит очевидным образом. false становится "false", null становится "null" и т.п.*/
let value = true;
alert(typeof value); //boolean

/*Численное преобразование - Number(value)
Численное преобразование происходит в математических функциях и выражениях.
Например, когда операция деления / применяется не к числу:*/
alert ("6"/"2"); // 3, строки преобразуются в числа.

let str = "123";
alert(typeof str); //string

/*Логическое преобразование, может быть выполнено явно с помощью функции Boolean(value)
 Правило преобразования:
- Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
- Все остальные значения становятся true. */
alert (Boolean(1)); // true
alert(Boolean(0)); // false

alert("Привет, Мир!!!"); // true
alert(""); // false

/* Базовые операторы
Операнд – то, к чему применяется оператор. 
Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».*/
let x = 1;
x = -x;
alert(x) // -1, применили унарный минус (унарный минус используется при одном операнде, н-р -)

let x = 2, y = 7;
alert(y-x); // 5, применили бинарный минус (бинарный минус используется при двух операндах, н-р х и у)

/*Взятие остатка - оператор
Результат a % b – это остаток от целочисленного деления a на b.*/
alert( 5 % 2 ); // 1, остаток от деления 5 на 2 - 4:2=2 и остаток 1
alert( 8 % 3 ); // 2, остаток от деления 8 на 3 - 6:3=2 и остаток 2

/*Возведение в степень - оператор
В выражении a ** b оператор возведения в степень умножает a на само себя b раз.*/
alert(2**2); // 4
alert(2**4); //16
alert(3**4); //81

/* Сложение строк при помощи бинарного + ТОЛЬКО СЛОЖЕНИЕ МОЖЕТ БЫТЬ СТРОКОЙ ИЛИ ЧИСЛОМ
бинарный оператор '+' применить к строкам, то он их объединяет в одну*/
 let s = "моя" + "строка";
 alert(s); // моястрока  
 //  если хотя бы один операнд является строкой(т.е. буквой или ``), то второй будет также преобразован в строку
 alert(`1`+2); //12
 alert(2+`1`); //21
 alert(5+50+`7`); //557
 /*Здесь операторы работают один за другим. Первый + складывает два числа и возвращает 55, 
 затем следующий + объединяет результат со строкой, производя действие 4 + '1' = 41.
 Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.
 */ 
alert(6 -`2`); // 4, '2' приводится к числу
alert(`6`/`2`); //3, оба операнда приводятся к числам

/*Приведение к числу, унарный +
Плюс + существует в двух формах: бинарной, которую мы использовали выше, и унарной.
Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.*/
let x3 = 1;
alert(+x3); // 1
let y3 = -2;
alert(+y3); // -2
// Преобразует не числа в числа !!! ОЧЕНЬ ВАЖНО
let (+true); // 1
alert(+""); // 0

let apples = "5";
let oranges = "7";
alert(apples+oranges); // 57 - сложение строк при помощи бинарного сложения

let apples12 = "5";
let oranges12 = "7";
alert (+apples12 + +oranges12); // 12 or alert(Number(apples)+Number(oranges)); // 12
/*Так как «унарный плюс» имеет приоритет 15, который выше, чем 12 у «сложения» (бинарный плюс), 
то в выражении "+apples + +oranges" сначала выполнятся унарные плюсы, а затем сложение.*/

/*Присваивание - Оператор = - самый низкий приоритет "2" в таблице*/
let x1 = 2*5+7;
alert(x1); // 17
/*Присваивание = возвращает значение*/
let a = 1;
let b = 2 ;
let c = 3-(a=b+1);
alert(a); //3
alert(c); //0
/**/
let a1, b1, c1;
c= 2+2;
b=c;
a=b;
alert(c); //4
alert(b); //4
alert(a); //4
/*Сокращенная арифметика с присваиванием*/
let n2 = 2;
let +=5; //теперь n2 = 7 (работает как n = n2 + 5)
let *=2; // теперь n2 = 14 (работает как n = n2 * 2)
alert(n2); //14
/**/
let n3 = 2;
n3 *=5+2;
alert(n3); //14

/*Инкремент ++ увеличивает переменную на 1, декремент -- уменьшает переменную на 1*/
let counter = 2;
counter ++;
alert(counter); //3
let counter1 = 3
counter1 --;
alert(counter1); //2
/*«постфиксная форма»(возвращает старое значение): counter++, «префиксная форма»(производит новое значение) — это когда оператор идёт перед переменной: ++counter
- приоритет выше, чем у математических операций*/
let counter21 = 1;
let a21 = ++counter21;
alert(a21); //2
let couter22 = 1;
let a22 = counter++;
alert(a22); //1

/*Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. 
Каждое выражение выполняется, но возвращается результат только последнего. Самый низкий приоритет*/
let a31 = (1+2, 3+4);
alert(a); // считается в итоге последнее 3+4 = 7

let a51 = 1, b51 = 1;
// a=2, b=2
let c51 = ++a; // 2
let d51 = b++; // 1

let a61 = 2;
// a=4
let x61 = 1+(a *=2); // 5

"" + 1 + 0 // 10 - здесь "" - это строка и все остальное приравнивается к СТРОКЕ
"" - 1 + 0 // -1 - а здесь "" это ноль 0, потому что здесь вычитание, 1 с отрицательным знаком идет -1, соответственно это идет уже ЧИСЛО
true + false // 1
6 / "3" // 2
"2" * "3" // 6
4 + 5 + "px" // 9px - это ЧИСЛО, значит производим математические действия (определяем по первому значку) ТОЛЬКО СЛОЖЕНИЕ МОЖЕТ БЫТЬ СТРОКОЙ ИЛИ ЧИСЛОМ
"$" + 4 + 5 // $45 - это же СТРОКА, значит мы соединяем все в один текст $45 (определяем по первому значку)ТОЛЬКО СЛОЖЕНИЕ МОЖЕТ БЫТЬ СТРОКОЙ ИЛИ ЧИСЛОМ
"4" - 2 // 2 - МИНУС НЕ МОЖЕТ БЫТЬ СТРОКОЙ, поэтому это число
"4px" - 2 // Nan
7 / 0 // Infinity
"  -9  " + 5 //-9 5 - здесь строка и + между двуся переменным объединяет их
"  -9  " - 5 //-14 - здесь строка превращается в число, потому что у нас минус, а не плюс в общей операции между переменными, поэтому мы производим обычную мат операцию.
null + 1 // 1
undefined + 1 // Nan   ToNumber(undefined) = NaN. NaN + 1 = NaN. 
" \t \n" - 2 // -2 - т.к. это минус, то в данном случае, что в кавычках у нас, преобразуется в ноль и итог очевиден 

let a2 = prompt("Первое число?", 1);
let b2 = prompt("Чторое число?", 2);
alert(+a + +b); //3 
 
/*Операторы сравнения 
== - равно
!= - не равно
a >= b, a <= b*/
let result = 5 > 4; // результат сравнения присваивается переменной result и имеет два значения true(верно) or false(неверно)
alert( result ); // true
//Сравнивается по алфавиту, как только буква больше, значит то слово и  больше становится. Но, если буква а маленькая, то она больше, чем А, согласно спецификации.
alert( 'Я' > 'А' ); // true 
alert( 'Коты' > 'Кода' ); // true
alert( 'Сонный' > 'Сон' ); // true

// Сравнение разных типов 
alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1
alert("2" > "12"); // true, число 2 больше числа 1 - сравниваем по строчно!!!

/* Строгое сравнение 
Оператор строгого равенства === проверяет равенство без приведения типов*/
alert( 0 === false ); // false - так как сравниваются разные типы

alert( null === undefined ); // false - при строгом равенстве неверны, потому что разные типы сравниваются
alert( null == undefined ); // true - при нестрогом равенстве верны

/*При использовании математических операторов и других операторов сравнения < > <= >= ВАЖНО!!!
Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN*/
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true


alert( undefined > 0 ); // false 
alert( undefined < 0 ); // false 
alert( undefined == 0 ); // false 

alert( null === undefined ); // false
alert( null == undefined ); // true

// Задачи
5 > 4 // true
"ананас" > "яблоко" // false
"2" > "12" // true
undefined == null // true
undefined === null // false 
null == "\n0\n" // false
null === +"\n0\n" // false

// Условное ветвление 
// Инструкция if вычисляет условие в скобках и, если результат true, то выполняет блок кода
/*Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).*/
if (year == 2015) {
    alert( "Правильно!" );
    alert( "Вы такой умный!" );
  }
  if (0) {  // 0 is falsy
      ...
  }
  if (1) { // 1 is truthy
      ...
  }
// Инструкция if может содержать необязательный блок «else» («иначе»). Он выполняется, когда условие ложно.
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year == 2015) {
  alert( 'Да вы знаток!' );
} else {
  alert( 'А вот и неправильно!' ); // любое значение, кроме 2015
}

let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');
if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}
// сначала проверит year < 2015. Если это неверно, он переходит к следующему условию year > 2015. Если оно тоже ложно, тогда сработает последний alert.
if (age < 3) {
    message = 'Здравствуй, малыш!';
  } else if  (age < 18) {
    message = 'Привет!';
  } else  if (age < 100) {
    message = 'Здравствуйте!';
  } else {
    message = 'Какой необычный возраст!';
  }

/*Условный оператор - низкий приоритет
Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.
let result = условие ? значение1 : значение2;
вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.
Смысл оператора «вопросительный знак» ? – вернуть то или иное значение, в зависимости от условия*/
let age = prompt('Возраст?', 18);
let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';
alert( message );

//Задачи
if ("0") {
    alert( 'Привет' );
  }

let nameJS = prompt(`Какое «официальное» название JavaScript?`, ``);

if (nameJS == ECMAScript) {
  alert("Верно!");
}
else {
  alert("Не знаете? ECMAScript!"); 
}



let number = prompt(`Введите число`, 0);

if (number > 0) {
  alert(1);
} 
else (number < 0) {
  alert(-1);
}
else (number=0) {
   alert(0);
} 



let result;

if (a + b < 4) {
  result = 'Мало';
} else {
  result = 'Много';
} 

result = (a + b < 4) ? `Мало` :
'Много';
alert(result);



let message;

if (login == 'Сотрудник') {
  message = 'Привет';
} 
else if (login == 'Директор') {
  message = 'Здравствуйте';
} 
else if (login == '') {
  message = 'Нет логина';
} 
else {
  message = '';
}
alert(message);

let message = (login == 'Сотрудник') ? 'Привет':
(login == 'Директор') ? 'Здравствуйте':
(login == '') ? 'Нет логина':
'';


//три логических оператора: || (ИЛИ), && (И) и ! (НЕ).
//Оператор «ИЛИ» - result = a || b; используется  для проверки истинности любого из заданных условий
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false

if (1 || 0) { // работает как if( true || false )
  alert( 'truthy!' );
}

let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'Офис закрыт.' ); // это выходной
}

// цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено. Это ИСТИНА
alert( 1 || 0 ); // 1
alert( true || 'no matter what' ); // true

alert( null || 1 ); // 1 (первое истинное значение)
alert( null || 0 || 1 ); // 1 (первое истинное значение)
alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)

let currentUser = null;
let defaultUser = "John";

let name = currentUser || defaultUser || "unnamed";

alert( name ); // выбирается "John" – первое истинное значение

// ИЛИ || вычисляет их слева направо. Вычисление останавливается при достижении первого истинного значения.

let x;

true || (x = 1);

alert(x); // undefined, потому что (x = 1) не вычисляется

//Если бы первый аргумент имел значение false, то || приступил бы к вычислению второго и выполнил операцию присваивания:
let x;

false || (x = 1);

alert(x); // 1

// этот вариант использования || является "аналогом if". Первый операнд преобразуется в логический. Если он оказывается ложным, начинается вычисление второго.

/* оператор "И" пишется как два амперсанда && - result = a && b; Приоритет оператора && больше, чем у ||  Это ЛОЖЬ
традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false:*/
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false

let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'The time is 12:30' );
}

if (1 && 0) { // вычисляется как true && false
  alert( "не сработает, так как результат ложный" );
}

// при result = value1 && value2 && value3; - производит вычисления слева направо в поисках false, И возвращает первое ложное значение. Или последнее, если ничего не найдено.

// Если первый операнд истинный,
// И возвращает второй:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0

alert( 1 && 2 && null && 3 ); // null

alert( 1 && 2 && 3 ); // 3

//Пример
let x = 1;

(x > 0) && alert( 'Greater than zero!' );

или

let x = 1;

if (x > 0) {
  alert( 'Greater than zero!' );
}

/* Оператор НЕ представлен восклицательным знаком ! - result = !value;  ! - это противоположное значение, !! - возвращает то же значение
Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||
Оператор принимает один аргумент и выполняет следующие действия:
1) Сначала приводит аргумент к логическому типу true/false.
2) Затем возвращает противоположное значение. */
alert( !true ); // false
alert( !0 ); // true

//То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое.
alert( !!"non-empty string" ); // true
alert( !!null ); // false




//Задачи
alert( null || 2 && 3 || 4 );
alert( null || 3 || 4 );
alert(3);

// Выполнится
// оператор && имеет больший приоритет, чем ||
// так что -1 && 1 выполнится раньше
// вычисления: null || -1 && 1  ->  null || 1  ->  1
if (null || -1 && 1) alert( 'third' );


// ИЛИ - || - ЭТО ИСТИНА; И - && - ЭТО ЛОЖЬ; НЕ - ! - ПРОТИВОПОЛОЖНОЕ ЗНАЧЕНИЕ (!! - ничего не меняется).
// Если false в alert - то ничего не выполнится

Задача

let login = prompt(`Кто там?`, '');

     if (login == `Админ`) {
         let pass = prompt (`Пароль?`, '');
         if (pass==`Я главный`) {
             alert(`Здравствуйте!`);
         }
         else if (pass=='' || pass==null) {
             alert(`Отменено`);
         }
         else {
             alert(`Неверный пароль`);
         }
     }
     else if (login == '' || login==null) {
         alert(`Отменено`);
     }
     else {
         alert(`Я вас не знаю`);
     }


 /*Оператор нулевого слияния - ??  проверка на null/undefined (они являются неопределенными значениями), если их нет, то выбирается первое определённое значение.
 оператор ?? вычисляется до = и ?, но после большинства других операций, таких как +, *.
 Запрещено использовать вместе с || или && без явно указанных круглых скобок.*/
 Результат выражения a ?? b будет следующим:

    a, если значение a определено,
    b, если значение a не определено.

    То есть оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй. Это всего лишь удобный синтаксис, как из двух значений получить одно «определённое».

    result = a ?? b:
    result = (a !== null && a !== undefined) ? a : 
    b;

    // будет height=100, если переменная height равна null или undefined
    height = height ?? 100;

    Например, в следующем примере, если переменная user не определена, покажем модальное окно с надписью Аноним:
    let user;

    alert(user ?? "Аноним"); // Аноним

    если бы переменная user содержала любое значение, кроме null/undefined, то мы бы увидели его:

    let user = "Иван";

    alert(user ?? "Аноним"); // Иван
// Задача
    let firstName = null;
    let lastName = null;
    let nickName = "Суперкодер";
    Выведем имя пользователя, используя одну из этих переменных, а в случае если все они не определены, то покажем «Аноним».
    // показывает первое определённое значение:
    alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер

    // возможна замена 
    let firstName = null;
    let lastName = null;
    let nickName = "Суперкодер";

    // показывает первое истинное значение:
    alert(firstName || lastName || nickName || "Аноним"); // Суперкодер

    Важное различие между || и ?? заключается в том, что:

    || возвращает первое истинное значение.
    ?? возвращает первое определённое значение.

    let height = 0;

    alert(height || 100); // 100 - показывает первое истинное значение
    alert(height ?? 100); // 0  - показывает первой определенное значение


    let height = null;
    let width = null;
    
    // важно: используйте круглые скобки
    let area = (height ?? 100) * (width ?? 50); - (в скобках первое значение null, оно неопределенное, значит идем дальше, второе 100, определенное - его и выбираем)
    
    alert(area); // 5000

    let x = (1 && 2) ?? 3; // Работает без ошибок

    alert(x); // 2


// Циклы while и for

Цикл while

while (condition) {
  // код
  // также называемый "телом цикла"
}
Код из тела цикла выполняется, пока условие condition истинно.

  let i = 0;
  while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++; //+1 инкремент - увеличивает переменную на +1
}
// Одно выполнение тела цикла по-научному называется итерация. Цикл в примере выше совершает три итерации.

let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--; //-1 декремент - увеличивает переменную на -1
}

// цикл Do...While - цикл проверки
do {
  // тело цикла
} while (condition);
//Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.

let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным

// цикл for

for (начало; условие; шаг) {
  // ... тело цикла ...
}

for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
Выполнить *начало*
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
→ ...

переменная внутри
// for (let i = 0; i < 3; i++) alert(i)

// Выполнить начало
let i = 0;
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { alert(i); i++ }
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { alert(i); i++ }
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { alert(i); i++ }
// ...конец, потому что теперь i == 3

переменная снаружи 

let i = 0;

for (i = 0; i < 3; i++) { // используем существующую переменную
  alert(i); // 0, 1, 2
}
alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла

// пропуск частей for
let i = 0; // мы уже имеем объявленную i с присвоенным значением

for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}

/*Чтобы организовать бесконечный цикл, используют конструкцию while (true). При этом он, как и любой другой цикл, может быть прерван директивой break.
Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву continue.
Обе этих директивы поддерживают метки, которые ставятся перед циклом. Метки – единственный способ для break/continue выйти 
за пределы текущего цикла, повлиять на выполнение внешнего.*/

//break - останавливаем цикл на том значение, которое мы задаем в if - принудительный выход

for (i=0; i<10, i++) {
  alert(i);
  if(i==5) break;
}
//contimue - пропускаем цикл на том значение, которое мы задаем в if - т.е. обработка каких-то конкретных условий

for (i=0; i<10; i++) { - // выполняем условия
  if(i % 2 == 0) continue; // проверяем итог, выбираем нечетное число
  console.log("i= "+i); // выводим на экран не остаток, а само нечетное число, которое используется при % 2
}

for (i=0; i<10; i++) {
  if(!(i % 2 == 0)) {
      console.log("i= "+i); // равнозначное действо {} вместе с оператором !(НЕ) тому же continue.

 Задача
 
 for (let i = 0; i < 5; i++) {
  alert(i); //0, 1, 2, 3, 4. - true ; 5 - false.
}
// или
let i = 0;

if (i<5) {
  alert(i);
  i++
} 

// Массивы=array

const en = "Английский";
const ru = "Русский";

const array = ["Английский", "Русский"]; // Массив [0,1] соответственно
//array[100] = "Белорусский";
//array[`tes`] = "Украинский";
//const array = [1, true, []]; // типы элементов внутри массива

//console.log(array[`length`]); 
//console.log(array.length); // длина массива
//console.log(typeof array); // тип массива
//console.log(array[1]); // конкретный индекс элемента 
console.log(array);


const arr = [1, 0, 55, 10, 531, 12, 15]; // 0,1,2,3,4,5,6

// for

//let i = 0;
//for (let i=0; i < array.length; i++ ) {
if (array[i]===55){
    break; // когда хотим выйти из цикла
}
 if (array[i]===55) {
     continue; // можем просто пропустить итерацию  ====55
 }
//console.log (array[i]);
//}   

let i = 0; // условие

// while

while(i<arr.length) {  // length = 7
    break; 
    continue;
    console.log(arr[i]);
    i++;
}*/

while (i<0) { // проверяет условия
    console.log (`test`); // выполняет код внутри
}

// do

do {
    console.log (`test2`); // выполняет код внутри
}  while (i<0); // проверяет условия

console.log(`end`);

// switch case

const name = `Alex`;

if (name===`Alex`) {
  console.log (`Привет, Alex`);
}
else if (name===`John`) {
  console.log (`Привет, John`);
}
else if (name===`Kate`) {
  console.log (`Привет, John`);
}
else {
  console.log (`Привет`);
}

// if...else = switch

switch(name) {
  case `Alex`: {
      const a = 10;
      console.log (`Привет, Alex`);
      break;
  }
  case `John`:
    console.log (`Привет, John`); 
    break; 
  case `Kate`:
    console.log (`Привет, Kate`);
    break;
  default:
    console.log (`Привет`);    
}

// Функции

function имя(параметры) {
  ...тело...
}

// Пример

// Какая итоговая сумма за весь товар?

const cart =[{
  name: `Арбуз`,
  price: 100,
  count: 1,
}, {
  name: `Хлеб`,
  price: 10,
  count: 2,
}, {
  name: `Молоко`,
  price: 50,
  count: 1,
}];

let finalPrice = 0;

for (let i=0, i < cart.length, i++){
  const product = cart[i];   // массив cart[i] = массив Арбуз + массив Хлеб + массив Молоко

  const price = product.price * product.count; // цена продукта * кол-во продукта - н-р: 100*1=100 или 10*2=20 = итог сумма за кол-во конкретного продукта

  finalPrice += price
}

console.log(finalPrice);